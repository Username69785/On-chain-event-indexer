# 1) Назначение и цель проекта

## 1.1. Назначение
Система собирает on-chain данные (транзакции/логи/события) за выбранный период (например, последние 24 часа), сохраняет в хранилище и предоставляет:
-   аналитические метрики и сводки;
-   скоринг/эвристику по адресам или сущностям;
-   отчёты (таблицы + графики);
-   алерты по правилам.

## 1.2. Цели
-   Получать ежедневную (и/или почасовую) картину активности.
-   Быстро отвечать на вопросы “что происходило” и “что подозрительно/важно”.
-   Иметь воспроизводимые отчёты и историю метрик.
-   Обеспечить устойчивость сбора данных при перезапусках и ошибках источников.

* * *

# 2) Область применения и ограничения

## 2.1. Область применения
-   Аналитический инструмент (read-only): сбор данных и анализ.
-   Не выполняет торговые операции, не подписывает транзакции, не взаимодействует с приватными ключами.

## 2.2. Поддерживаемые сети
-   MVP: **одна** блокчейн-сеть (например, Solana или EVM-сеть) — определяется конфигурацией.
-   Архитектура должна позволять добавлять другие сети без изменения пользовательского слоя (дашборд/отчёты).

## 2.3. Декодирование “семантики” протоколов
-   Система должна уметь работать в двух режимах:
    1.  **Базовая аналитика** без глубокого декодирования протокола (по программам/контрактам, адресам, комиссиям, трансферам).
    2.  **Семантическая аналитика** для выбранных протоколов при наличии их описаний форматов (например, IDL/ABI).
-   Если описание формата отсутствует, данные всё равно должны сохраняться в “сыром” виде и учитываться в базовой статистике.

* * *

# 3) Роли пользователей и сценарии

## 3.1. Роли
-   **Пользователь (аналитик):** смотрит дашборд, формирует отчёты, настраивает правила алертов.
-   **Администратор:** настраивает источники данных, расписание задач, параметры хранения, доступ.

## 3.2. Основные сценарии
1.  Запустить сбор данных за последние 24 часа и получить отчёт.
2.  Включить регулярный режим (ежедневно/почасово) и получать обновления.
3.  Открыть дашборд и увидеть графики + топ-списки.
4.  Открыть карточку адреса и увидеть скоринг, историю активности, связанные события.
5.  Получить алерт при выполнении условия (например, “кошелёк сделал N крупных операций за час”).

* * *

# 4) Состав системы (компоненты)

## 4.1. Компоненты
1.  **Индексатор данных (Rust-часть)**
    Результат: стабильный процесс/сервис, который извлекает on-chain данные и записывает в хранилище.
2.  **Хранилище данных**
    Результат: структурированное хранилище “сырого” и “нормализованного” слоя + слой витрин/агрегаций.
3.  **Аналитика/скоринг (Python-часть)**
    Результат: набор задач, которые строят метрики, скоринг, аномалии, отчёты, подготовленные данные для UI.
4.  **Дашборд / админ-панель**
    Результат: веб-интерфейс для просмотра статистики, фильтрации, выгрузки и управления правилами.
5.  **Подсистема алертов**
    Результат: отправка уведомлений по правилам (например, Telegram/Discord/email) + журнал алертов.

* * *

# 5) Требования к индексатору (Rust-часть)

## 5.1. Режимы работы
Индексатор должен поддерживать:
-   **Batch режим:** собрать данные за заданный период времени/слотов/блоков (например, последние 24 часа).
-   **Continuous режим:** непрерывно собирать новые данные и дописывать в хранилище.
-   **Backfill режим:** догружать пропущенные интервалы после простоя.

## 5.2. Корректность и устойчивость
Индексатор должен обеспечивать:
-   **Продолжение после перезапуска** без потери целостности данных.
-   **Защиту от дублей** при повторной обработке.
-   **Точки прогресса (checkpoint)** для каждого источника/сети.
-   **Поведение при ошибках источника** (временная недоступность, лимиты, таймауты) без повреждения данных.

## 5.3. Что индексируется (минимальный набор)
Для каждого объекта/события должна сохраняться как минимум:
-   Идентификатор (tx id / signature / hash).
-   Временная привязка (slot/block number, timestamp).
-   Статус (успешно/ошибка).
-   Участники (адреса/аккаунты) — если доступны в исходных данных.
-   Комиссии/ресурсы (если сеть это предоставляет).
-   Список вызванных программ/контрактов (где применимо).
-   Сырые логи/сообщения (если доступны).

## 5.4. Декодирование событий протокола (опционально, но предусмотрено)
Система должна:
-   Позволять конфигурировать список “интересующих” программ/контрактов.
-   Если для программы задано описание формата (например, IDL/ABI), индексатор должен сохранять:
    -   тип события/инструкции (человекочитаемое имя),
    -   ключевые параметры (например amount, token, pool, min_out и т.п. — согласно формату),
    -   связь с исходной транзакцией и индексом инструкции/лога.
-   Если формата нет — сохранять “сырой payload” и метаданные, но без расшифровки.

## 5.5. Наблюдаемость (для эксплуатации)
Индексатор должен выдавать:
-   понятные логи о ходе обработки;
-   счётчики обработанных объектов (за период/за минуту);
-   счётчики ошибок по категориям;
-   информацию о текущем чекпоинте и отставании.

* * *

# 6) Требования к хранилищу данных

## 6.1. Слои данных
Хранилище должно включать:
-   **Raw слой**: максимально близкий к источнику (для повторной обработки и аудита).
-   **Normalized слой**: таблицы/структуры, удобные для аналитики и JOIN/AGG.
-   **Mart/витрины**: агрегированные таблицы для дашборда и отчётов (день/час/неделя).

## 6.2. Минимальные сущности (логические таблицы)
Должны существовать сущности (названия условные):
-   `raw_transactions` (сырой объект транзакции)
-   `raw_logs` (логи/сообщения)
-   `transactions` (нормализованная транзакция)
-   `participants` или `tx_accounts` (участники/аккаунты транзакции)
-   `program_calls` / `contract_calls` (факт вызова программ/контрактов)
-   `token_transfers` (выделенные трансферы токенов, если возможно)
-   `decoded_events` (семантические события, если включено)
-   `checkpoints` (точки прогресса индексатора)
-   `job_runs` (история запусков задач/статусы)
-   `alerts` (журнал отправленных алертов)

## 6.3. Целостность данных
-   Должны быть уникальные идентификаторы, предотвращающие дубли.
-   Должна храниться связь: событие → транзакция → окно времени.
-   Должны быть предусмотрены индексы/ключи для быстрых запросов по:
    -   времени (timestamp/slot/block),
    -   адресу,
    -   program_id/contract,
    -   типу события.

* * *

# 7) Требования к аналитике и скорингу (Python-часть)

## 7.1. Планировщик аналитики
Должны быть аналитические задачи:
-   ежедневный расчёт за последние 24 часа;
-   (опционально) почасовые расчёты;
-   перерасчёт при догрузке данных (backfill).
Каждая задача должна фиксировать:
-   время запуска/окончания;
-   объём обработанных данных;
-   статус (успех/ошибка) и причину ошибки.

## 7.2. Метрики (минимальный набор)
Дашборд/отчёт должен уметь строить как минимум:
-   количество транзакций за период;
-   количество уникальных активных адресов;
-   топ программ/контрактов по взаимодействиям;
-   распределение комиссий/ресурсов (если доступно);
-   количество и объём токен-трансферов (если собирается);
-   временные ряды (по часам) ключевых метрик.

## 7.3. Скоринг/эвристики (минимальный MVP)
Должна быть система скоринга (конфигурируемая), которая для адресов/сущностей рассчитывает:
-   показатель активности (частота операций);
-   показатель “масштаба” (объёмы/крупные операции — если доступны);
-   показатель новизны (новые адреса в периоде);
-   простые признаки аномальности (всплески активности, необычное поведение относительно истории).
Результат скоринга должен быть:
-   числовой итоговый score (например 0–100);
-   набор вкладов/факторов (почему такой score);
-   храниться по времени (история score).

## 7.4. (Опционально) Кластеризация/связность адресов
Если включено, система должна уметь:
-   строить связи адресов по совместным транзакциям/взаимодействиям;
-   выделять кластеры;
-   показывать кластер в UI (размер, основные адреса, тип активности).

## 7.5. Отчёты
Система должна генерировать отчёты за период (например, сутки):
-   краткое summary (ключевые цифры + изменения относительно прошлого периода);
-   таблицы “топ-N” (адреса, программы, события);
-   графики временных рядов;
-   список “важных событий” по правилам.
Форматы отчёта (минимум один):
-   веб-страница/HTML;
-   (опционально) PDF;
-   выгрузка CSV для таблиц.

* * *

# 8) Требования к дашборду / админ-панели

## 8.1. Основные страницы UI
Должны быть доступны:
1.  **Обзор (Overview)**
    Метрики за выбранный период + графики + сравнение с прошлым периодом.
2.  **Транзакции/События**
    Список событий с фильтрами: период, адрес, программа/контракт, тип события, статус.
3.  **Адрес (Address profile)**
    История активности, скоринг, топ взаимодействий, подозрительные события.
4.  **Программы/Контракты**
    Рейтинг по активности, тренды, топ события.
5.  **Алерты**
    История алертов + правила + статусы отправки.
6.  **Служебное**
    Статус индексатора, чекпоинт, последние ошибки, последние job-runs.

## 8.2. Функции UI
-   Выбор периода (последние 24ч, 7д, кастомный диапазон).
-   Фильтры и поиск по адресам и идентификаторам транзакций.
-   Экспорт таблиц (CSV) из ключевых списков.
-   Отображение причин скоринга (факторы).

* * *

# 9) Требования к алертам

## 9.1. Каналы алертов
MVP: один канал (например, Telegram/Discord/email) — выбирается конфигурацией.

## 9.2. Правила алертов (минимальный набор)
Должна быть возможность включить правила вида:
-   “адрес сделал ≥ N транзакций за T минут/час”
-   “транзакция/событие по программе X удовлетворяет условию Y”
-   “score адреса превысил порог”
-   “обнаружен всплеск метрики (аномалия)”

## 9.3. Дедуп уведомлений
Система должна предотвращать спам:
-   не отправлять одинаковый алерт многократно за короткий период;
-   хранить журнал отправленных алертов.

* * *

# 10) Конфигурация и управление

## 10.1. Конфигурационные параметры
Должны задаваться без изменения кода:
-   сеть/окружение (mainnet/testnet и т.п.)
-   RPC/WS endpoints
-   период отчёта (24ч/1ч)
-   список отслеживаемых программ/контрактов (если применимо)
-   включение/выключение семантического декодирования
-   параметры скоринга/порогов
-   параметры алертов и каналы отправки

## 10.2. Управление задачами
Должны быть команды/действия:
-   запустить batch сбор за период;
-   запустить backfill за период;
-   запустить расчёт отчёта за период;
-   посмотреть статус последнего запуска и ошибки.

* * *

# 11) Нефункциональные требования

## 11.1. Надёжность
-   Система должна работать в режиме регулярных запусков без ручного вмешательства.
-   После перезапуска индексатор продолжает с последнего чекпоинта.
-   Данные не должны теряться и не должны множиться при повторном запуске.

## 11.2. Производительность (минимально)
-   Отчёт за последние 24 часа должен строиться за разумное время на обычном VPS/ПК (целевое время фиксируется в критериях приёмки).
-   Дашборд должен открывать обзор и основные списки без заметных задержек на типичных объёмах данных.

## 11.3. Безопасность
-   Секреты (ключи доступа к БД/каналам алертов) не должны попадать в логи.
-   Дашборд (если доступен извне) должен иметь базовую защиту доступа (минимум: пароль/ключ).

* * *

# 12) Критерии приёмки (Definition of Done)
Проект считается готовым (MVP), если выполняется всё ниже:
1.  Можно запустить сбор данных за последние 24 часа и получить заполненное хранилище (raw + normalized).
2.  Можно повторно запустить сбор за тот же период без появления дублей в нормализованных таблицах.
3.  Можно построить отчёт за последние 24 часа с:
    -   ключевыми метриками,
    -   минимум 3 графиками,
    -   минимум 3 таблицами топ-N.
4.  В дашборде доступны страницы: Overview, Events/Transactions, Address profile, Alerts, Status.
5.  Работает минимум 2 правила алертов и ведётся журнал отправленных уведомлений.
6.  Есть журнал запусков задач (job_runs) и статус индексатора/чекпоинта.
7.  Система конфигурируется без изменения исходников (endpoints, окна, правила).

* * *

# 13) Опциональные расширения (после MVP)
-   Поддержка второй сети.
-   Семантическое декодирование конкретного протокола (через IDL/ABI) + витрина “Swap/Deposit/Borrow”.
-   Кластеризация адресов и визуализация графа.
-   PDF-отчёты и автопубликация отчётов по расписанию.
-   API для внешних клиентов (только чтение).
-   Более продвинутая система аномалий.